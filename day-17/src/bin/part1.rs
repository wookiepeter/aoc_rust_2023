use std::{
    cmp::Ordering,
    collections::{BinaryHeap, HashMap},
    path, usize,
};

use aoc_util::{
    direction::*,
    grid::*,
    manhattan_dist, print_hash_map_values,
    usize_point::{point_add, Point},
};

fn main() {
    let input = include_str!("./input.txt");
    let output = process(input);
    dbg!(output);
}

fn process(input: &str) -> String {
    let grid: Grid<usize> = Grid::new(input, |c: char| c.to_digit(10).unwrap() as usize);
    let start: Point = (0, 0);
    let goal: Point = (grid.size.0 - 1, grid.size.1 - 1);

    // What data do i need to save for a path?
    // I don't actually need the path, i just need the cost to get there!
    //
    // current direction (horizontal or vertical)
    // current position
    // cost so far

    // cool optimisation / simplification i found was to always add all possible states
    // (as in walk 1 or 2 or 3 steps in each direction) and then sort that into an
    // the priority queue using current heat and greedy evaluation to keep the sortation

    // Keep a dict with all already visited positions,
    //      -> # of steps used to reach this node + heat generated on that path + horizontal / vertical

    // TODO: Try and figure out an iterative solution for DFS because of [this](https://www.algobreath.com/notes/recursion-vs-iteration-in-rust)

    // use a BinaryHeap to do the priority queueing -> just need to flip the order!

    let visited: HashMap<(Point, bool), usize> = HashMap::new();
    let mut queue: BinaryHeap<GraphState> = BinaryHeap::new();

    queue.push(GraphState::new(start, 0, Direction::Right, &grid));
    queue.push(GraphState::new(start, 0, Direction::Down, &grid));

    let mut data = Data {
        queue,
        grid,
        visited,
    };

    while let Some(state) = data.queue.pop() {
        if state.last_step_horizontal {
            add_steps_in_direction(&state, &mut data, Direction::Down);
            add_steps_in_direction(&state, &mut data, Direction::Up);
        } else {
            add_steps_in_direction(&state, &mut data, Direction::Right);
            add_steps_in_direction(&state, &mut data, Direction::Left);
        }
    }

    // grab lowest heat and substract the heat generated by the goal
    let heat = std::cmp::min(
        data.visited.get(&(goal, true)).unwrap(),
        data.visited.get(&(goal, false)).unwrap(),
    );

    // debug visualization to help figure this shit out
    /*
    let mut debug_map: HashMap<Point, usize> = HashMap::new();
    for ((position, horizontal), heat) in data.visited.iter() {
        if !debug_map.contains_key(position) {
            let smallest_heat = match data.visited.get(&(*position, !horizontal)) {
                Some(other_heat) => heat.min(other_heat),
                None => heat,
            };
            debug_map.insert(*position, *smallest_heat);
        }
    }

    let debug_string = print_hash_map_values(debug_map, data.grid.size);
    println!("{}", debug_string);
    */

    heat.to_string()
}

struct Data {
    queue: BinaryHeap<GraphState>,
    grid: Grid<usize>,
    visited: HashMap<(Point, bool), usize>,
}

#[derive(PartialEq, Eq, Clone, Copy)]
struct GraphState {
    position: Point,
    heat: usize,
    last_step_horizontal: bool,
    evaluation: usize,
}

impl Ord for GraphState {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.evaluation.cmp(&other.evaluation).reverse()
    }
}

// probably not the way to do things but this is just used to satisfy trait bounds
impl PartialOrd for GraphState {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl GraphState {
    pub fn new(
        position: Point,
        heat: usize,
        last_dir: Direction,
        grid: &Grid<usize>,
    ) -> GraphState {
        GraphState {
            position,
            heat,
            last_step_horizontal: last_dir.is_horizontal(),
            evaluation: heat + manhattan_dist(&position, &grid.size),
        }
    }
}

fn add_steps_in_direction(state: &GraphState, data: &mut Data, dir: Direction) {
    let mut current_state = *state;
    for _ in 0..3 {
        if let Some(position) = point_add(current_state.position, dir.into(), data.grid.size) {
            let new_state = GraphState::new(
                position,
                current_state.heat + data.grid.get(position).unwrap(),
                dir,
                &data.grid,
            );

            match data
                .visited
                .get(&(new_state.position, new_state.last_step_horizontal))
            {
                Some(value) if *value <= new_state.heat => {
                    current_state = new_state;
                    continue;
                }
                None | Some(_) => {
                    data.visited.insert(
                        (new_state.position, new_state.last_step_horizontal),
                        new_state.heat,
                    );
                }
            }
            /*
            println!(
                "Added position with {:?} with heat {}",
                new_state.position, new_state.heat
            );
            */
            data.queue.push(new_state);
            current_state = new_state;
        } else {
            return;
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::process;

    #[test]
    fn test_example() {
        let result = process(
            "2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533",
        );
        assert_eq!(result, "102".to_string())
    }
}

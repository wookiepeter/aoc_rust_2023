use std::collections::{BinaryHeap, HashMap};

use aoc_util::{direction::*, grid::*, usize_point::Point};
use day_17::*;

fn main() {
    let input = include_str!("./input.txt");
    let output = process(input);
    dbg!(output);
}

fn process(input: &str) -> String {
    let grid: Grid<usize> = Grid::new(input, |c: char| c.to_digit(10).unwrap() as usize);
    let start: Point = (0, 0);
    let goal: Point = (grid.size.0 - 1, grid.size.1 - 1);

    // What data do i need to save for a path?
    // I don't actually need the path, i just need the cost to get there!
    //
    // current direction (horizontal or vertical)
    // current position
    // cost so far

    // cool optimisation / simplification i found was to always add all possible states
    // (as in walk 1 or 2 or 3 steps in each direction) and then sort that into an
    // the priority queue using current heat and greedy evaluation to keep the sortation

    // Keep a dict with all already visited positions,
    //      -> # of steps used to reach this node + heat generated on that path + horizontal / vertical

    // use a BinaryHeap to do the priority queueing -> just need to flip the order!

    let visited: HashMap<(Point, bool), usize> = HashMap::new();
    let mut queue: BinaryHeap<GraphState> = BinaryHeap::new();

    queue.push(GraphState::new(start, 0, Direction::Right, &grid));
    queue.push(GraphState::new(start, 0, Direction::Down, &grid));

    let mut data = Data {
        queue,
        grid,
        visited,
    };

    while let Some(state) = data.queue.pop() {
        if state.last_step_horizontal {
            add_steps_in_direction(&state, &mut data, Direction::Down, 0..3);
            add_steps_in_direction(&state, &mut data, Direction::Up, 0..3);
        } else {
            add_steps_in_direction(&state, &mut data, Direction::Right, 0..3);
            add_steps_in_direction(&state, &mut data, Direction::Left, 0..3);
        }
    }

    // grab lowest heat and substract the heat generated by the goal
    let heat = std::cmp::min(
        data.visited.get(&(goal, true)).unwrap(),
        data.visited.get(&(goal, false)).unwrap(),
    );

    // debug visualization to help figure this shit out
    /*
    let mut debug_map: HashMap<Point, usize> = HashMap::new();
    for ((position, horizontal), heat) in data.visited.iter() {
        if !debug_map.contains_key(position) {
            let smallest_heat = match data.visited.get(&(*position, !horizontal)) {
                Some(other_heat) => heat.min(other_heat),
                None => heat,
            };
            debug_map.insert(*position, *smallest_heat);
        }
    }

    let debug_string = print_hash_map_values(debug_map, data.grid.size);
    println!("{}", debug_string);
    */

    heat.to_string()
}

#[cfg(test)]
mod tests {
    use crate::process;

    #[test]
    fn test_example() {
        let result = process(
            "2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533",
        );
        assert_eq!(result, "102".to_string())
    }
}
